import mysql.connector
import os
from datetime import datetime
import bcrypt

# Define database connection details (replace with your MySQL credentials)
DB_CONFIG = {
    'host': 'localhost',
    'user': 'your_mysql_user',
    'password': 'your_mysql_password',
    'database': 'real_estate_mysql'
}

class DatabaseManager:
    """
    Manages all interactions with the MySQL database for the Real Estate Management System.
    """
    def __init__(self):
        self._create_database_if_not_exists()
        self._create_tables()

    def _get_connection(self):
        """
        Returns a connection object to the MySQL database.
        """
        try:
            conn = mysql.connector.connect(**DB_CONFIG)
            return conn
        except mysql.connector.Error as err:
            print(f"Error connecting to MySQL: {err}")
            return None

    def _create_database_if_not_exists(self):
        """Ensures the database exists before connecting to it."""
        try:
            # Connect to MySQL without specifying a database to create it
            conn = mysql.connector.connect(
                host=DB_CONFIG['host'],
                user=DB_CONFIG['user'],
                password=DB_CONFIG['password']
            )
            cursor = conn.cursor()
            cursor.execute(f"CREATE DATABASE IF NOT EXISTS {DB_CONFIG['database']}")
            conn.commit()
            cursor.close()
            conn.close()
            print(f"Database '{DB_CONFIG['database']}' ensured to exist.")
        except mysql.connector.Error as err:
            print(f"Error creating database: {err}")

    def _create_tables(self):
        """Initializes the database by creating tables if they don't exist."""
        try:
            with self._get_connection() as conn:
                if not conn:
                    return

                cursor = conn.cursor()

                # 1. Users Table (Must be created first due to foreign key constraints)
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS users (
                        user_id INT AUTO_INCREMENT PRIMARY KEY,
                        username VARCHAR(255) NOT NULL UNIQUE,
                        password_hash VARCHAR(255) NOT NULL,
                        is_agent ENUM('yes', 'no') DEFAULT 'no',
                        role ENUM('user', 'admin', 'accountant', 'property_manager', 'sales_agent') DEFAULT 'user'
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 2. Properties Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS properties (
                        property_id INT AUTO_INCREMENT PRIMARY KEY,
                        property_type ENUM('Block', 'Lot') NOT NULL,
                        title_deed_number VARCHAR(255) NOT NULL,
                        location VARCHAR(255) NOT NULL,
                        size DECIMAL(10, 2) NOT NULL,
                        description TEXT,
                        owner VARCHAR(255) NOT NULL,
                        contact VARCHAR(255) NOT NULL,
                        price DECIMAL(10, 2) NOT NULL,
                        image_paths TEXT,
                        title_image_paths TEXT,
                        status ENUM('Available', 'Unavailable', 'Sold') NOT NULL DEFAULT 'Available',
                        added_by_user_id INT,
                        FOREIGN KEY (added_by_user_id) REFERENCES users(user_id)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 3. PropertiesForTransfer Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS propertiesForTransfer (
                        property_id INT AUTO_INCREMENT PRIMARY KEY,
                        title_deed_number VARCHAR(255) NOT NULL,
                        location VARCHAR(255) NOT NULL,
                        size DECIMAL(10, 2) NOT NULL,
                        description TEXT,
                        owner VARCHAR(255) NOT NULL,
                        contact VARCHAR(255) NOT NULL,
                        image_paths TEXT,
                        title_image_paths TEXT,
                        added_by_user_id INT,
                        FOREIGN KEY (added_by_user_id) REFERENCES users(user_id)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 4. Clients Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS clients (
                        client_id INT AUTO_INCREMENT PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        contact_info VARCHAR(255) UNIQUE NOT NULL,
                        status ENUM('active', 'inactive') NOT NULL DEFAULT 'active',
                        added_by_user_id INT,
                        FOREIGN KEY (added_by_user_id) REFERENCES users(user_id)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 5. Transactions Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS transactions (
                        transaction_id INT AUTO_INCREMENT PRIMARY KEY,
                        property_id INT NOT NULL,
                        client_id INT NOT NULL,
                        payment_mode ENUM('Cash', 'Installments') NOT NULL,
                        total_amount_paid DECIMAL(10, 2) NOT NULL,
                        discount DECIMAL(10, 2) DEFAULT 0.0,
                        balance DECIMAL(10, 2) DEFAULT 0.0,
                        transaction_date DATETIME NOT NULL,
                        receipt_path TEXT,
                        added_by_user_id INT,
                        FOREIGN KEY (property_id) REFERENCES properties(property_id),
                        FOREIGN KEY (client_id) REFERENCES clients(client_id),
                        FOREIGN KEY (added_by_user_id) REFERENCES users(user_id)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 6. SurveyJobs Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS survey_jobs (
                        job_id INT AUTO_INCREMENT PRIMARY KEY,
                        client_id INT NOT NULL,
                        property_location VARCHAR(255) NOT NULL,
                        job_description TEXT,
                        fee DECIMAL(10, 2) NOT NULL,
                        amount_paid DECIMAL(10, 2) DEFAULT 0.0,
                        balance DECIMAL(10, 2) DEFAULT 0.0,
                        deadline DATE NOT NULL,
                        status ENUM('Pending', 'Ongoing', 'Completed', 'Cancelled') NOT NULL DEFAULT 'Pending',
                        attachments_path TEXT,
                        added_by_user_id INT NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        receipt_creation_path TEXT,
                        FOREIGN KEY (client_id) REFERENCES clients(client_id),
                        FOREIGN KEY (added_by_user_id) REFERENCES users(user_id)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 7. ProposedLots Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS proposed_lots (
                        lot_id INT AUTO_INCREMENT PRIMARY KEY,
                        parent_block_id INT NOT NULL,
                        size DECIMAL(10, 2) NOT NULL,
                        location VARCHAR(255) NOT NULL,
                        surveyor_name VARCHAR(255) NOT NULL,
                        created_by VARCHAR(255) NOT NULL,
                        title_deed_number VARCHAR(255),
                        price VARCHAR(255) DEFAULT '0.0',
                        status ENUM('Proposed', 'Confirmed', 'Rejected') NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (parent_block_id) REFERENCES properties(property_id)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 8. PropertyTransfers Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS property_transfers (
                        transfer_id INT AUTO_INCREMENT PRIMARY KEY,
                        property_id INT NOT NULL,
                        from_client_id INT,
                        to_client_id INT NOT NULL,
                        transfer_price DECIMAL(10, 2) NOT NULL,
                        transfer_date DATE NOT NULL,
                        executed_by_user_id INT NOT NULL,
                        supervising_agent_id INT,
                        transfer_document_path TEXT,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (property_id) REFERENCES properties(property_id),
                        FOREIGN KEY (from_client_id) REFERENCES clients(client_id),
                        FOREIGN KEY (to_client_id) REFERENCES clients(client_id),
                        FOREIGN KEY (executed_by_user_id) REFERENCES users(user_id),
                        FOREIGN KEY (supervising_agent_id) REFERENCES users(user_id)
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 9. Agents Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS agents (
                         agent_id INT AUTO_INCREMENT PRIMARY KEY,
                         name VARCHAR(255) NOT NULL,
                         status ENUM('active', 'inactive') DEFAULT 'active',
                         added_by VARCHAR(255) NOT NULL,
                         timestamp DATETIME NOT NULL
                     ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 10. PaymentPlans Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS payment_plans (
                        plan_id INT AUTO_INCREMENT PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        deposit_percentage DECIMAL(5, 2) NOT NULL CHECK(deposit_percentage >= 0 AND deposit_percentage <= 100),
                        duration_months INT NOT NULL,
                        interest_rate DECIMAL(5, 2) NOT NULL,
                        created_by VARCHAR(255) NOT NULL
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 11. ServiceClients Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS service_clients (
                        client_id INT AUTO_INCREMENT PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        contact VARCHAR(255) UNIQUE NOT NULL,
                        brought_by VARCHAR(255),
                        added_by VARCHAR(255) NOT NULL,
                        timestamp DATETIME NOT NULL
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 12. ClientFiles Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS client_files (
                        file_id INT AUTO_INCREMENT PRIMARY KEY,
                        client_id INT NOT NULL,
                        file_name VARCHAR(255) NOT NULL,
                        added_by VARCHAR(255) NOT NULL,
                        timestamp DATETIME NOT NULL,
                        FOREIGN KEY (client_id) REFERENCES service_clients(client_id) ON DELETE CASCADE
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 13. ServiceJobs Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS service_jobs (
                        job_id INT AUTO_INCREMENT PRIMARY KEY,
                        file_id INT NOT NULL,
                        job_description TEXT,
                        title_name VARCHAR(255) NOT NULL,
                        title_number VARCHAR(255) NOT NULL,
                        fee DECIMAL(10, 2) NOT NULL,
                        amount_paid DECIMAL(10, 2) DEFAULT 0.0,
                        status ENUM('Ongoing', 'Completed', 'Dispatched') NOT NULL DEFAULT 'Ongoing',
                        added_by VARCHAR(255) NOT NULL,
                        brought_by VARCHAR(255) NOT NULL,
                        timestamp DATETIME NOT NULL,
                        FOREIGN KEY (file_id) REFERENCES client_files(file_id) ON DELETE CASCADE
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 14. ServicePayments Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS service_payments (
                        payment_id INT AUTO_INCREMENT PRIMARY KEY,
                        job_id INT NOT NULL,
                        amount DECIMAL(10, 2) NOT NULL,
                        payment_date DATE NOT NULL,
                        payment_type ENUM('cash', 'bank', 'mpesa') DEFAULT 'unpaid',
                        status ENUM('paid', 'unpaid') DEFAULT 'unpaid',
                        FOREIGN KEY (job_id) REFERENCES service_jobs(job_id) ON DELETE CASCADE
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                # 15. ServiceDispatch Table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS service_dispatch (
                        dispatch_id INT AUTO_INCREMENT PRIMARY KEY,
                        job_id INT NOT NULL,
                        dispatch_date DATE NOT NULL,
                        reason_for_dispatch TEXT,
                        collected_by VARCHAR(255),
                        collector_phone VARCHAR(255),
                        sign BLOB,
                        FOREIGN KEY (job_id) REFERENCES service_jobs(job_id) ON DELETE CASCADE
                    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
                ''')

                conn.commit()
                print("Database initialized successfully.")
        except mysql.connector.Error as e:
            print(f"Error creating tables: {e}")
        except Exception as e:
            print(f"An unexpected error occurred during table creation: {e}")

    def _execute_query(self, query, params=(), fetch_one=False, fetch_all=False):
        """
        A helper method to execute SQL queries for MySQL.
        Returns dictionary-like rows.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn:
                return None
            cursor = conn.cursor(dictionary=True) # Returns dict-like rows
            cursor.execute(query, params)
            conn.commit()

            if fetch_one:
                return cursor.fetchone()
            if fetch_all:
                return cursor.fetchall()

            # For INSERT, return the last row ID
            if query.strip().upper().startswith("INSERT"):
                return cursor.lastrowid

            # For UPDATE/DELETE, check if any rows were affected
            if query.strip().upper().startswith(("UPDATE", "DELETE")):
                return cursor.rowcount > 0

            return None
        except mysql.connector.IntegrityError as e:
            print(f"Database Integrity Error: {e}. This usually means a unique value constraint was violated.")
            if conn:
                conn.rollback()
            return None
        except mysql.connector.Error as e:
            print(f"MySQL error: {e}")
            if conn:
                conn.rollback()
            return None
        except Exception as e:
            print(f"An unexpected error occurred in _execute_query: {e}")
            if conn:
                conn.rollback()
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    ## User Management Methods
    def add_user(self, username, password, is_agent='no', role='user'):
        """
        Adds a new user to the database with a hashed password.
        Returns: The ID of the newly added user, or None on error (e.g., duplicate username).
        """
        try:
            hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
            query = "INSERT INTO users (username, password_hash, is_agent, role) VALUES (%s, %s, %s, %s)"
            return self._execute_query(query, (username, hashed_password, is_agent, role))
        except Exception as e:
            print(f"Error adding user: {e}")
            return None

    def authenticate_user(self, username, password):
        """
        Verifies user credentials for login.
        Returns: The user's data (user_id, username, role) as a dict if valid, None otherwise.
        """
        query = "SELECT user_id, username, password_hash, role FROM users WHERE username = %s"
        user_data_row = self._execute_query(query, (username,), fetch_one=True)

        if user_data_row:
            user_data = user_data_row
            stored_password_hash = user_data['password_hash'].encode('utf-8')
            if bcrypt.checkpw(password.encode('utf-8'), stored_password_hash):
                del user_data['password_hash']
                return user_data
        return None

    def get_user_by_username(self, username):
        """
        Retrieves user data by username without password authentication.
        Returns: The user's data (user_id, username, role) as a dict if found, None otherwise.
        """
        query = "SELECT user_id, username, role FROM users WHERE username = %s"
        user_data_row = self._execute_query(query, (username,), fetch_one=True)
        return user_data_row if user_data_row else None

    def get_user_by_id(self, user_id):
        """
        Retrieves a user by their ID.
        Returns: The user's data (excluding password_hash) as a dict, or None if not found.
        """
        query = "SELECT user_id, username, role FROM users WHERE user_id = %s"
        user_data_row = self._execute_query(query, (user_id,), fetch_one=True)
        return user_data_row if user_data_row else None

    def update_user_password(self, user_id, new_password):
        """
        Updates a user's password.
        Returns: True if the update was successful, False otherwise.
        """
        hashed_password = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        query = "UPDATE users SET password_hash = %s WHERE user_id = %s"
        return self._execute_query(query, (hashed_password, user_id))

    def update_user_role(self, user_id, new_role):
        """
        Updates a user's role.
        Returns: True if the update was successful, False otherwise.
        """
        if new_role not in ['user', 'admin', 'accountant', 'property_manager', 'sales_agent']:
            print("Invalid role specified.")
            return False
        query = "UPDATE users SET role = %s WHERE user_id = %s"
        return self._execute_query(query, (new_role, user_id))

    def get_all_users(self):
        """Retrieves all user records from the database."""
        try:
            rows = self._execute_query("SELECT user_id, username, role FROM users", fetch_all=True)
            return rows if rows else []
        except Exception as e:
            print(f"Error fetching all users: {e}")
            return []

    def update_user(self, user_id, new_username=None, new_password=None, new_role=None):
        """Updates an existing user's details."""
        try:
            query_parts = []
            params = []
            if new_username:
                query_parts.append("username = %s")
                params.append(new_username)
            if new_password:
                query_parts.append("password_hash = %s")
                params.append(bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8'))
            if new_role:
                query_parts.append("role = %s")
                params.append(new_role)

            if not query_parts:
                return False

            query = "UPDATE users SET " + ", ".join(query_parts) + " WHERE user_id = %s"
            params.append(user_id)

            row_count = self._execute_query(query, tuple(params))
            return row_count is not None and row_count > 0
        except mysql.connector.IntegrityError:
            print(f"Username '{new_username}' already exists.")
            return False
        except Exception as e:
            print(f"Error updating user: {e}")
            return False

    def delete_user(self, user_id):
        """Deletes a user from the database."""
        try:
            row_count = self._execute_query("DELETE FROM users WHERE user_id = %s", (user_id,))
            return row_count is not None and row_count > 0
        except Exception as e:
            print(f"Error deleting user: {e}")
            return False

    def get_username_by_id(self, user_id):
        """
        Fetches the username of a user based on their user ID.
        Returns: The username if found, otherwise None.
        """
        try:
            row = self._execute_query(
                "SELECT username FROM users WHERE user_id = %s",
                (user_id,),
                fetch_one=True
            )
            if row:
                return row['username']
            return None
        except Exception as e:
            print(f"Error fetching username for user ID '{user_id}': {e}")
            return None

    ## CRUD Operations for Properties
    def get_properties_by_title_deed(self, title_deed_number):
        """
        Retrieves ALL properties matching a given title deed number.
        Returns: A list of dictionaries representing matching properties.
        """
        query = "SELECT * FROM properties WHERE title_deed_number = %s;"
        results_rows = self._execute_query(query, (title_deed_number,), fetch_all=True)
        return results_rows if results_rows else []

    def add_property(self, property_type, title_deed_number, location, size, description, owner, contact, price, image_paths=None, title_image_paths=None, status='Available', added_by_user_id=None):
        """
        Adds a new property to the database and ensures the owner is in the clients table.
        """
        existing_properties = self.get_properties_by_title_deed(title_deed_number)
        client_status = 'active'

        for prop in existing_properties:
            if prop['status'].lower() == 'available':
                print(f"Property with title deed '{title_deed_number}' already exists and is 'Available'. Cannot add duplicate.")
                return None

        client_exists = self.get_client_by_contact_info(contact)
        if not client_exists:
            self.add_client(name=owner, contact_info=contact, status=client_status, added_by_user_id=added_by_user_id)

        query = '''INSERT INTO properties (property_type, title_deed_number, location, size, description, owner, contact, price, image_paths, title_image_paths, status, added_by_user_id)
                     VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'''
        return self._execute_query(query, (property_type, title_deed_number, location, size, description, owner, contact, price, image_paths, title_image_paths, status, added_by_user_id))

    def get_propertiesfortransfer_by_title_deed(self, title_deed_number):
        """
        Retrieves ALL properties for transfer matching a given title deed number.
        Returns: A list of dictionaries representing matching properties.
        """
        query = "SELECT * FROM propertiesForTransfer WHERE title_deed_number = %s;"
        results_rows = self._execute_query(query, (title_deed_number,), fetch_all=True)
        return results_rows if results_rows else []

    def add_propertyForTransfer(self, title_deed_number, location, size, description, owner, contact, image_paths=None, title_image_paths=None, added_by_user_id=None):
        """
        Adds a new property for transfer to the database and ensures the owner is in the clients table.
        """
        existing_properties = self.get_propertiesfortransfer_by_title_deed(title_deed_number)
        client_status = 'active'

        for prop in existing_properties:
            print(f"Property with title deed '{title_deed_number}' already exists. Cannot add duplicate.")
            return None

        client_exists = self.get_client_by_contact_info(contact)
        if not client_exists:
            self.add_client(name=owner, contact_info=contact, status=client_status, added_by_user_id=added_by_user_id)

        query = '''INSERT INTO propertiesForTransfer (title_deed_number, location, size, description, owner, contact, image_paths, title_image_paths, added_by_user_id)
                     VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)'''
        return self._execute_query(query, (title_deed_number, location, size, description, owner, contact, image_paths, title_image_paths, added_by_user_id))

    def get_property(self, property_id):
        """
        Retrieves a property by its ID.
        Returns: The property details as a dict, or None if not found.
        """
        query = "SELECT * FROM properties WHERE property_id = %s"
        property_data_row = self._execute_query(query, (property_id,), fetch_one=True)
        return property_data_row if property_data_row else None

    def get_all_properties(self, status=None):
        """
        Retrieves all properties, optionally filtered by status.
        Returns: A list of dictionaries representing properties.
        """
        query = "SELECT * FROM properties"
        params = ()
        if status:
            query += " WHERE status = %s"
            params = (status,)
        results_rows = self._execute_query(query, params, fetch_all=True)
        return results_rows if results_rows else []

    def get_all_properties_lots(self, status=None, property_type=None):
        """
        Retrieves all properties, optionally filtered by status and property type.
        Returns: A list of dictionaries representing properties.
        """
        query = "SELECT * FROM properties WHERE 1=1"
        params = []
        if status:
            query += " AND status = %s"
            params.append(status)
        if property_type:
            query += " AND property_type = %s"
            params.append(property_type)
        results_rows = self._execute_query(query, tuple(params), fetch_all=True)
        return results_rows if results_rows else []

    def get_all_properties_blocks(self, status=None, property_type=None):
        """
        Retrieves all properties, optionally filtered by status and property type.
        Returns: A list of dictionaries representing properties.
        """
        query = "SELECT * FROM properties WHERE 1=1"
        params = []
        if status:
            query += " AND status = %s"
            params.append(status)
        if property_type:
            query += " AND property_type = %s"
            params.append(property_type)
        results_rows = self._execute_query(query, tuple(params), fetch_all=True)
        return results_rows if results_rows else []

    def update_property(self, property_id, **kwargs):
        """
        Updates details of an existing property.
        Returns: True if the update was successful, False otherwise.
        """
        set_clauses = []
        params = []
        for key, value in kwargs.items():
            if key in ['title_deed_number', 'location', 'size', 'description', 'price', 'image_paths', 'title_image_paths', 'status']:
                set_clauses.append(f"{key} = %s")
                params.append(value)

        if not set_clauses:
            print("No valid columns provided for property update.")
            return False

        params.append(property_id)
        query = f"UPDATE properties SET {', '.join(set_clauses)} WHERE property_id = %s"
        return self._execute_query(query, params)

    def delete_property(self, property_id):
        """
        Deletes a property from the database.
        Returns: True if deletion was successful, False otherwise.
        """
        query = "DELETE FROM properties WHERE property_id = %s"
        return self._execute_query(query, (property_id,))

    def get_total_properties(self):
        """
        Returns the total count of properties.
        Returns: Total number of properties.
        """
        query = "SELECT COUNT(*) FROM properties"
        result_row = self._execute_query(query, fetch_one=True)
        return result_row['COUNT(*)'] if result_row else 0

    def get_all_properties_paginated(self, limit=None, offset=None, search_query=None, min_size=None, max_size=None, status=None):
        """
        Fetches properties with optional search, size filters, status, and pagination,
        including the username of the user who added the property.
        Returns properties ordered by property_id DESC (newest first).

        Returns: A list of dictionaries, each representing a property, including 'added_by_username'.
        """
        query = """
        SELECT
            p.property_id,
            p.property_type,
            p.title_deed_number,
            p.location,
            p.size,
            p.description,
            p.price,
            p.contact,
            p.image_paths,
            p.title_image_paths,
            p.status,
            p.added_by_user_id,
            p.owner,
            u.username AS added_by_username
        FROM
            properties p
        LEFT JOIN
            users u ON p.added_by_user_id = u.user_id
        WHERE 1=1
        """
        params = []

        if search_query:
            query += " AND (p.title_deed_number LIKE %s OR p.location LIKE %s OR p.description LIKE %s)"
            params.extend([f"%{search_query}%", f"%{search_query}%", f"%{search_query}%"])

        if min_size is not None:
            query += " AND p.size >= %s"
            params.append(min_size)

        if max_size is not None:
            query += " AND p.size <= %s"
            params.append(max_size)

        if status:
            query += " AND p.status = %s"
            params.append(status)

        query += " ORDER BY p.property_id DESC"

        if limit is not None:
            query += " LIMIT %s"
            params.append(limit)

        if offset is not None:
            query += " OFFSET %s"
            params.append(offset)

        results_rows = self._execute_query(query, tuple(params), fetch_all=True)
        return results_rows if results_rows else []

    ## CRUD Operations for Clients
    def add_client(self, name, contact_info, status, added_by_user_id=None):
        """
        Adds a new client to the database, tracking the user who added them.
        Returns: The ID of the new client, or None on error/duplicate contact_info.
        """
        query = "INSERT INTO clients (name, contact_info, status, added_by_user_id) VALUES (%s, %s, %s, %s)"
        return self._execute_query(query, (name, contact_info, status, added_by_user_id))

    def get_client(self, client_id):
        """
        Retrieves a client by their ID.
        Returns: The client details as a dict, or None if not found.
        """
        query = "SELECT * FROM clients WHERE client_id = %s"
        client_data_row = self._execute_query(query, (client_id,), fetch_one=True)
        return client_data_row if client_data_row else None

    def get_client_by_contact_info(self, contact_info):
        """
        Retrieves a client by their contact information.
        Returns: The client details as a dict, or None if not found.
        """
        query = "SELECT * FROM clients WHERE contact_info = %s"
        client_data_row = self._execute_query(query, (contact_info,), fetch_one=True)
        return client_data_row if client_data_row else None

    def get_all_clients(self):
        """
        Retrieves all clients from the database, including the username of the user who added them.
        Returns: A list of dictionaries representing clients.
        """
        query = """
        SELECT
            c.client_id,
            c.name,
            c.contact_info,
            c.status,
            c.added_by_user_id,
            u.username AS added_by_username
        FROM
            clients c
        LEFT JOIN
            users u ON c.added_by_user_id = u.user_id
        WHERE
            c.status = 'active'
        ORDER BY c.name ASC
        """
        results_rows = self._execute_query(query, fetch_all=True)
        return results_rows if results_rows else []

    def get_all_clients_fortransferform(self):
        """
        Retrieves all clients from the database, including the username of the user who added them.
        Returns: A list of dictionaries representing clients.
        """
        query = """
        SELECT
            c.client_id,
            c.name,
            c.contact_info,
            c.status,
            c.added_by_user_id,
            u.username AS added_by_username
        FROM
            clients c
        LEFT JOIN
            users u ON c.added_by_user_id = u.user_id
        ORDER BY c.name ASC
        """
        results_rows = self._execute_query(query, fetch_all=True)
        return results_rows if results_rows else []

    def update_client(self, client_id, **kwargs):
        """
        Updates details of an existing client.
        Returns: True if the update was successful, False otherwise.
        """
        set_clauses = []
        params = []
        for key, value in kwargs.items():
            if key in ['name', 'contact_info']:
                set_clauses.append(f"{key} = %s")
                params.append(value)

        if not set_clauses:
            print("No valid columns provided for client update.")
            return False

        params.append(client_id)
        query = f"UPDATE clients SET {', '.join(set_clauses)} WHERE client_id = %s"
        return self._execute_query(query, params)

    def delete_client(self, client_id):
        """
        Deletes a client from the database.
        Returns: True if deletion was successful, False otherwise.
        """
        query = "UPDATE clients SET status = 'inactive' WHERE client_id = %s"
        print(f"Executing query for client ID {client_id}: {query}")
        return self._execute_query(query, (client_id,))

    def get_total_clients(self):
        """
        Returns the total count of clients.
        Returns: Total number of clients.
        """
        query = "SELECT COUNT(*) FROM clients WHERE status = 'active'"
        result_row = self._execute_query(query, fetch_one=True)
        return result_row['COUNT(*)'] if result_row else 0

    def get_client_by_id(self, client_id):
        """
        Retrieves client details by ID, formatted as a dictionary.
        """
        try:
            query = "SELECT * FROM clients WHERE client_id = %s"
            client_data_row = self._execute_query(query, (client_id,), fetch_one=True)
            return client_data_row if client_data_row else None
        except Exception as e:
            print(f"Error getting client by ID: {e}")
            return None

    ## CRUD Operations for Transactions
    def add_transaction(self, property_id, client_id, payment_mode, total_amount_paid, discount=0.0, balance=0.0, receipt_path=None, added_by_user_id=None):
        """
        Adds a new sales transaction.
        Returns: The ID of the newly added transaction, or None on error.
        """
        transaction_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        query = '''INSERT INTO transactions (property_id, client_id, payment_mode, total_amount_paid, discount, balance, transaction_date, receipt_path, added_by_user_id)
                      VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)'''
        return self._execute_query(query, (property_id, client_id, payment_mode, total_amount_paid, discount, balance, transaction_date, receipt_path, added_by_user_id))

    def get_transaction(self, transaction_id):
        """
        Retrieves a transaction by its ID.
        Returns: The transaction details as a dict, or None if not found.
        """
        query = "SELECT * FROM transactions WHERE transaction_id = %s"
        transaction_data_row = self._execute_query(query, (transaction_id,), fetch_one=True)
        return transaction_data_row if transaction_data_row else None

    def get_transactions_by_property(self, property_id):
        """
        Retrieves all transactions related to a specific property.
        Returns: A list of dictionaries representing transactions.
        """
        query = "SELECT * FROM transactions WHERE property_id = %s"
        results_rows = self._execute_query(query, (property_id,), fetch_all=True)
        return results_rows if results_rows else []

    def get_transactions_by_client(self, client_id):
        """
        Retrieves all transactions related to a specific client.
        Returns: A list of dictionaries representing transactions.
        """
        query = "SELECT * FROM transactions WHERE client_id = %s"
        results_rows = self._execute_query(query, (client_id,), fetch_all=True)
        return results_rows if results_rows else []

    def get_all_transactions(self):
        """
        Retrieves all transactions from the database.
        Returns: A list of dictionaries representing transactions.
        """
        query = "SELECT * FROM transactions"
        results_rows = self._execute_query(query, fetch_all=True)
        return results_rows if results_rows else []

    def get_total_pending_sales_payments(self):
        """
        Calculates the sum of outstanding balances from property transactions.
        Returns: Total pending amount from sales, or 0.0 if none.
        """
        query = "SELECT SUM(balance) FROM transactions WHERE balance > 0"
        result_row = self._execute_query(query, fetch_one=True)
        return float(result_row['SUM(balance)']) if result_row and result_row['SUM(balance)'] is not None else 0.0

    def update_transaction(self, transaction_id, **kwargs):
        """
        Updates details of an existing transaction.
        Returns: True if the update was successful, False otherwise.
        """
        set_clauses = []
        params = []
        allowed_columns = [
            'property_id', 'client_id', 'payment_mode', 'total_amount_paid',
            'discount', 'balance', 'transaction_date', 'receipt_path', 'added_by_user_id'
        ]

        for key, value in kwargs.items():
            if key in allowed_columns:
                set_clauses.append(f"{key} = %s")
                params.append(value)
            else:
                print(f"Warning: Attempted to update disallowed column: {key}")

        if not set_clauses:
            print("No valid columns provided for transaction update.")
            return False

        params.append(transaction_id)
        query = f"UPDATE transactions SET {', '.join(set_clauses)} WHERE transaction_id = %s"

        return self._execute_query(query, params)

    def get_transactions_with_details(self, status=None, start_date=None, end_date=None, payment_mode=None, client_name_search=None, property_search=None, client_contact_search=None):
        """
        Retrieves transactions with details from linked properties and clients,
        allowing for various filtering options, including client contact info.

        Returns: A list of dictionaries, where each dictionary contains combined
                    transaction, client, and property details.
        """
        query = """
        SELECT
            t.transaction_id,
            t.transaction_date,
            t.payment_mode,
            t.total_amount_paid,
            t.discount,
            t.balance,
            t.receipt_path,
            c.name AS client_name,
            c.contact_info AS client_contact_info,
            p.property_id,
            p.title_deed_number,
            p.location,
            p.size,
            p.price AS property_price,
            p.status AS property_status
        FROM
            transactions t
        JOIN
            clients c ON t.client_id = c.client_id
        JOIN
            properties p ON t.property_id = p.property_id
        WHERE 1=1
        """
        params = []

        if status == 'complete':
            query += " AND t.balance = 0"
        elif status == 'pending':
            query += " AND t.balance > 0"

        if start_date:
            query += " AND t.transaction_date >= %s"
            params.append(f"{start_date} 00:00:00")

        if end_date:
            query += " AND t.transaction_date <= %s"
            params.append(f"{end_date} 23:59:59")

        if payment_mode:
            query += " AND t.payment_mode = %s"
            params.append(payment_mode)

        if client_name_search:
            query += " AND c.name LIKE %s"
            params.append(f"%{client_name_search}%")

        if property_search:
            query += " AND (p.title_deed_number LIKE %s OR p.location LIKE %s)"
            params.append(f"%{property_search}%")
            params.append(f"%{property_search}%")

        if client_contact_search:
            query += " AND c.contact_info LIKE %s"
            params.append(f"%{client_contact_search}%")

        query += " ORDER BY t.transaction_date DESC"

        results_rows = self._execute_query(query, params, fetch_all=True)
        return results_rows if results_rows else []

    ## NEW METHODS FOR SOLD PROPERTIES UI
    def get_total_sold_properties_count(self, start_date=None, end_date=None):
        """
        Returns the total count of properties with 'Sold' status, optionally filtered by transaction date.
        Returns: Total number of sold properties matching criteria.
        """
        query = "SELECT COUNT(*) FROM properties p JOIN transactions t ON p.property_id = t.property_id WHERE p.status = 'Sold'"
        params = []

        if start_date:
            query += " AND t.transaction_date >= %s"
            params.append(f"{start_date} 00:00:00")
        if end_date:
            query += " AND t.transaction_date <= %s"
            params.append(f"{end_date} 23:59:59")

        result_row = self._execute_query(query, params, fetch_one=True)
        return result_row['COUNT(*)'] if result_row else 0

    def get_sold_properties_paginated(self, limit, offset, start_date=None, end_date=None):
        """
        Retrieves sold properties along with their transaction and client details,
        supporting pagination and date filtering.

        Returns: A list of dictionaries, each containing details for a sold property.
        """
        query = """
        SELECT
            p.property_id,
            p.title_deed_number,
            p.location,
            p.size,
            p.price AS original_price,
            t.transaction_id,
            t.transaction_date AS date_sold,
            t.total_amount_paid,
            t.discount,
            t.balance,
            c.name AS name,
            c.contact_info AS client_contact_info
        FROM
            properties p
        JOIN
            transactions t ON p.property_id = t.property_id
        JOIN
            clients c ON t.client_id = c.client_id
        WHERE
            p.status = 'Sold'
        """
        params = []

        if start_date:
            query += " AND t.transaction_date >= %s"
            params.append(f"{start_date} 00:00:00")
        if end_date:
            query += " AND t.transaction_date <= %s"
            params.append(f"{end_date} 23:59:59")

        query += """
        ORDER BY
            t.transaction_date DESC, p.title_deed_number ASC
        LIMIT %s OFFSET %s
        """
        params.extend([limit, offset])

        results_rows = self._execute_query(query, params, fetch_all=True)
        return results_rows if results_rows else []

    def count_available_properties(self):
        """Returns the count of properties with 'Available' status."""
        query = "SELECT COUNT(*) FROM properties WHERE status = 'Available'"
        result_row = self._execute_query(query, fetch_one=True)
        return result_row['COUNT(*)'] if result_row else 0

    def add_service_client(self, name, contact, brought_by, added_by):
        """
        Adds a new client to the database. The 'file_name' is now handled
        separately in the `client_files` table.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor()
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            cursor.execute('''
                INSERT INTO service_clients (name, contact, brought_by, added_by, timestamp)
                VALUES (%s, %s, %s, %s, %s)
            ''', (name, contact, brought_by, added_by, timestamp))
            conn.commit()
            return cursor.lastrowid
        except mysql.connector.IntegrityError:
            return None
        except mysql.connector.Error as e:
            print(f"MySQL error adding service client: {e}")
            if conn: conn.rollback()
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def add_client_file(self, client_id, file_name, added_by):
        """
        Adds a new file for an existing client.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor()
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            cursor.execute('''
                INSERT INTO client_files (client_id, file_name, added_by, timestamp)
                VALUES (%s, %s, %s, %s)
            ''', (client_id, file_name, added_by, timestamp))
            conn.commit()
            return cursor.lastrowid
        except mysql.connector.IntegrityError:
            return None
        except mysql.connector.Error as e:
            print(f"MySQL error adding client file: {e}")
            if conn: conn.rollback()
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_all_client_files(self):
        """
        Retrieves all client files from the database, joining with the
        service_clients table to include client names and contact info.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            query = """
                SELECT
                    cf.file_id,
                    cf.file_name,
                    sc.name AS client_name,
                    sc.contact AS contact
                FROM
                    client_files cf
                JOIN
                    service_clients sc ON cf.client_id = sc.client_id
                ORDER BY
                    sc.name
            """
            cursor.execute(query)
            files = cursor.fetchall()
            return files
        except mysql.connector.Error as e:
            print(f"Database error: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_all_service_clients(self):
        """
        Retrieves all clients from the database (now only client info, not files).
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            cursor.execute('SELECT client_id, name, contact FROM service_clients ORDER BY name')
            clients = cursor.fetchall()
            return clients
        except mysql.connector.Error as e:
            print(f"MySQL error fetching all service clients: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_file_by_id(self, file_id):
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor(dictionary=True)
            cursor.execute("SELECT * FROM client_files WHERE file_id = %s", (file_id,))
            file_data = cursor.fetchone()
            return file_data
        except mysql.connector.Error as e:
            print(f"MySQL error getting file by ID: {e}")
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_service_client_by_id(self, client_id):
        """Retrieves a single client by their ID."""
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor(dictionary=True)
            cursor.execute('SELECT * FROM service_clients WHERE client_id = %s', (client_id,))
            client_data = cursor.fetchone()
            return client_data
        except mysql.connector.Error as e:
            print(f"MySQL error getting service client by ID: {e}")
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def update_service_client(self, client_id, new_data):
        """Updates a client's information."""
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return False
            cursor = conn.cursor()
            set_clause = ', '.join([f"{key} = %s" for key in new_data.keys()])
            values = list(new_data.values())
            values.append(client_id)
            cursor.execute(f'UPDATE service_clients SET {set_clause} WHERE client_id = %s', values)
            conn.commit()
            return cursor.rowcount > 0
        except mysql.connector.Error as e:
            print(f"MySQL error updating service client: {e}")
            if conn: conn.rollback()
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def delete_service_client(self, client_id):
        """Deletes a client and all associated files, jobs, and payments."""
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return False
            cursor = conn.cursor()

            # MySQL handles CASCADE, so deleting the client will delete related records
            cursor.execute('DELETE FROM service_clients WHERE client_id = %s', (client_id,))

            conn.commit()
            return cursor.rowcount > 0
        except mysql.connector.Error as e:
            print(f"An error occurred: {e}")
            if conn: conn.rollback()
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    # --- CRUD for Service Jobs ---
    def add_job(self, file_id, job_description, title_name, title_number, fee, amount_paid, added_by, brought_by):
        """
        Adds a new job for a specific file. This method now takes 'file_id'
        instead of 'client_id'.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor()
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            cursor.execute('''
                INSERT INTO service_jobs (file_id, job_description, title_name, title_number, fee, amount_paid, added_by, brought_by, timestamp)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            ''', (file_id, job_description, title_name, title_number, fee, amount_paid , added_by, brought_by, timestamp))
            conn.commit()
            return cursor.lastrowid
        except mysql.connector.Error as e:
            print(f"MySQL error adding job: {e}")
            if conn: conn.rollback()
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_all_jobs(self):
        """
        Retrieves all jobs, joining with the client_files and service_clients
        tables to include client and file information.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            query = """
                SELECT
                    sj.*,
                    cf.file_name,
                    sc.name AS client_name,
                    sc.contact AS contact
                FROM
                    service_jobs sj
                JOIN
                    client_files cf ON sj.file_id = cf.file_id
                JOIN
                    service_clients sc ON cf.client_id = sc.client_id
                ORDER BY
                    sj.timestamp DESC
            """
            cursor.execute(query)
            jobs = cursor.fetchall()
            return jobs
        except mysql.connector.Error as e:
            print(f"Database error: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_jobs_by_file_id(self, file_id):
        """
        Retrieves all jobs for a specific client file. This method replaces
        the old get_jobs_by_client_id.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            cursor.execute('SELECT * FROM service_jobs WHERE file_id = %s', (file_id,))
            jobs = cursor.fetchall()
            return jobs
        except mysql.connector.Error as e:
            print(f"MySQL error getting jobs by file ID: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_job_details(self, job_id):
        """
        Fetches detailed information for a single job, including client and file info.
        This method now matches the requested format.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor(dictionary=True)
            query = """
            SELECT
                sj.job_id,
                sj.job_description,
                sj.title_name,
                sj.title_number,
                cf.file_name,
                sc.name AS client_name
            FROM service_jobs sj
            JOIN client_files cf ON sj.file_id = cf.file_id
            JOIN service_clients sc ON cf.client_id = sc.client_id
            WHERE sj.job_id = %s
            """
            cursor.execute(query, (job_id,))
            row = cursor.fetchone()
            return row
        except mysql.connector.Error as e:
            print(f"Error fetching job details for ID {job_id}: {e}")
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def update_job(self, job_id, new_data):
        """Updates a job's information."""
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return False
            cursor = conn.cursor()
            set_clause = ', '.join([f"{key} = %s" for key in new_data.keys()])
            values = list(new_data.values())
            values.append(job_id)
            cursor.execute(f'UPDATE service_jobs SET {set_clause} WHERE job_id = %s', values)
            conn.commit()
            return cursor.rowcount > 0
        except mysql.connector.Error as e:
            print(f"MySQL error updating job: {e}")
            if conn: conn.rollback()
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def update_job_status(self, job_id, new_status):
        """
        Updates only the status of a specific job.

        This method uses the more general update_job function, making it
        more specific and easier to use for this particular task.

        Args:
            job_id (int): The unique ID of the job.
            new_status (str): The new status for the job (e.g., 'Ongoing', 'Completed').

        Returns:
            bool: True if the update was successful, False otherwise.
        """
        new_data = {'status': new_status}
        return self.update_job(job_id, new_data)

    def delete_job(self, job_id):
        """Deletes a job and its associated payments."""
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return False
            cursor = conn.cursor()

            # MySQL handles CASCADE, so deleting the job will delete related payments
            cursor.execute('DELETE FROM service_jobs WHERE job_id = %s', (job_id,))
            conn.commit()
            return True
        except mysql.connector.Error as e:
            print(f"An error occurred: {e}")
            if conn: conn.rollback()
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_completed_jobs(self):
        """
        Retrieves all service jobs from the database that have a 'Completed' status.
        The result includes the file name and client name by joining tables.

        Returns:
            list: A list of dictionaries, where each dict is a 'Completed' job.
                  Returns an empty list on failure.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            query = """
                SELECT
                    sj.job_id,
                    sj.timestamp,
                    sj.job_description,
                    sj.title_name,
                    sj.title_number,
                    cf.file_name,
                    sc.name AS client_name,
                    sj.status
                FROM
                    service_jobs sj
                JOIN
                    client_files cf ON sj.file_id = cf.file_id
                JOIN
                    service_clients sc ON cf.client_id = sc.client_id
                WHERE
                    sj.status = 'Completed'
            """
            cursor.execute(query)
            rows = cursor.fetchall()
            return rows
        except mysql.connector.Error as e:
            print(f"An error occurred while fetching data: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_dispatched_jobs(self):
        """
        Fetches all records from the dispatch table.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            query = """
            SELECT dispatch_id, job_id, dispatch_date, reason_for_dispatch, collected_by, collector_phone
            FROM service_dispatch
            ORDER BY dispatch_date DESC
            """
            cursor.execute(query)
            dispatched_jobs = cursor.fetchall()
            return dispatched_jobs
        except mysql.connector.Error as e:
            print(f"Error fetching dispatch records: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def save_dispatch_details(self, job_id, dispatch_date, reason, collected_by, phone, sign_blob):
        """
        Inserts new dispatch details into the service_dispatch table.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return False
            cursor = conn.cursor()
            insert_query = """
            INSERT INTO service_dispatch (job_id, dispatch_date, reason_for_dispatch, collected_by, collector_phone, sign)
            VALUES (%s, %s, %s, %s, %s, %s)
            """
            update_query = """
            UPDATE service_jobs
            SET status = 'Dispatched'
            WHERE job_id = %s
            """
            cursor.execute(insert_query, (job_id, dispatch_date, reason, collected_by, phone, sign_blob))
            cursor.execute(update_query, (job_id,))
            conn.commit()
            return True
        except mysql.connector.Error as e:
            print(f"Error saving dispatch details: {e}")
            if conn: conn.rollback()
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    # --- CRUD for Service Payments ---
    def add_payment(self, job_id, amount):
        """Records a new payment for a job and updates the job's balance."""
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor()
            payment_date = datetime.now().strftime('%Y-%m-%d')
            cursor.execute('''
                INSERT INTO service_payments (job_id, amount, payment_date)
                VALUES (%s, %s, %s)
            ''', (job_id, amount, payment_date))
            conn.commit()
            return cursor.lastrowid
        except mysql.connector.Error as e:
            print(f"An error occurred: {e}")
            if conn: conn.rollback()
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_payments_by_job_id(self, job_id):
        """Retrieves all payments for a specific job."""
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            cursor.execute('SELECT * FROM service_payments WHERE job_id = %s', (job_id,))
            payments = cursor.fetchall()
            return payments
        except mysql.connector.Error as e:
            print(f"MySQL error getting payments by job ID: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_all_payments(self):
        """
        Retrieves all payments with detailed information from related tables.
        Returns a list of dictionaries.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            query = """
                SELECT
                    sp.payment_id,
                    sc.name AS client_name,
                    cf.file_name,
                    sj.job_description,
                    sj.title_number,
                    sp.amount,
                    sp.status AS payment_status,
                    sp.payment_type,
                    sp.payment_date
                FROM service_payments AS sp
                JOIN service_jobs AS sj ON sp.job_id = sj.job_id
                JOIN client_files AS cf ON sj.file_id = cf.file_id
                JOIN service_clients AS sc ON cf.client_id = sc.client_id
                ORDER BY sp.payment_date DESC;
            """
            cursor.execute(query)
            return cursor.fetchall()
        except mysql.connector.Error as e:
            print(f"Error fetching payments: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_filtered_payments(self, filters, page=1, page_size=20):
        """
        Retrieves a filtered and paginated list of payments.

        Args:
            filters (dict): Dictionary of filters (e.g., 'status', 'client_name').
            page (int): The current page number (1-based).
            page_size (int): The number of items per page.

        Returns:
            tuple: A tuple containing a list of payment records and the total count.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn:
                return [], 0
            cursor = conn.cursor(dictionary=True)

            base_query = """
                FROM service_payments AS sp
                JOIN service_jobs AS sj ON sp.job_id = sj.job_id
                JOIN client_files AS cf ON sj.file_id = cf.file_id
                JOIN service_clients AS sc ON cf.client_id = sc.client_id
            """

            conditions = []
            params = []

            if 'status' in filters and filters['status'] != 'All':
                conditions.append("sp.status = %s")
                params.append(filters['status'])

            if 'payment_mode' in filters and filters['payment_mode']:
                conditions.append("sp.payment_type = %s")
                params.append(filters['payment_mode'])

            if 'client_name' in filters and filters['client_name']:
                conditions.append("sc.name LIKE %s")
                params.append(f"%{filters['client_name']}%")

            if 'file_name' in filters and filters['file_name']:
                conditions.append("cf.file_name LIKE %s")
                params.append(f"%{filters['file_name']}%")

            if 'title_number' in filters and filters['title_number']:
                conditions.append("sj.title_number LIKE %s")
                params.append(f"%{filters['title_number']}%")

            if 'from_date' in filters and filters['to_date']:
                conditions.append("sp.payment_date BETWEEN %s AND %s")
                params.append(filters['from_date'])
                params.append(filters['to_date'])

            where_clause = " WHERE " + " AND ".join(conditions) if conditions else ""

            count_query = f"SELECT COUNT(*) {base_query}{where_clause}"
            cursor.execute(count_query, params)
            total_count = cursor.fetchone()['COUNT(*)']

            data_query = f"""
                SELECT
                    sp.payment_id,
                    sc.name AS client_name,
                    cf.file_name,
                    sj.job_description,
                    sj.title_number,
                    sp.amount,
                    sp.status,
                    sp.payment_type,
                    sp.payment_date
                {base_query}{where_clause}
                ORDER BY sp.payment_date DESC
                LIMIT %s OFFSET %s;
            """
            offset = (page - 1) * page_size
            params.extend([page_size, offset])

            cursor.execute(data_query, params)
            payments = cursor.fetchall()

            return payments, total_count
        except mysql.connector.Error as e:
            print(f"Error fetching filtered payments: {e}")
            return [], 0
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def update_payment_record(self, payment_id, new_status, payment_type):
        """
        Updates the status and payment type of a specific payment.

        Returns:
            bool: True on success, False on failure.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return False
            cursor = conn.cursor()
            cursor.execute(
                "UPDATE service_payments SET status = %s, payment_type = %s WHERE payment_id = %s",
                (new_status, payment_type, payment_id)
            )
            conn.commit()
            return cursor.rowcount > 0
        except mysql.connector.Error as e:
            print(f"Error updating payment record: {e}")
            if conn: conn.rollback()
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_total_survey_jobs(self):
        """
        Returns the total count of service jobs.
        Returns: Total number of service jobs.
        """
        query = "SELECT COUNT(*) FROM service_jobs"
        result_row = self._execute_query(query, fetch_one=True)
        return result_row['COUNT(*)'] if result_row else 0

    def get_survey_job_status_counts(self):
        """
        Returns a dictionary of survey job status counts.
        e.g., {'Pending': 5, 'Ongoing': 2, 'Completed': 8, 'Cancelled': 1}
        """
        query = "SELECT status, COUNT(*) FROM survey_jobs GROUP BY status"
        results_rows = self._execute_query(query, fetch_all=True)
        return {row['status']: row['COUNT(*)'] for row in results_rows} if results_rows else {}

    ## NEW REPORTING METHODS (FOR SalesReportsForm)
    def get_total_sales_for_date_range(self, start_date, end_date):
        """
        Retrieves total revenue and total properties sold within a specified date range.
        Assumes 'transaction_date' in 'transactions' table is stored as YYYY-MM-DD HH:MM:SS.
        """
        try:
            query = """
                SELECT
                    SUM(t.total_amount_paid + t.balance) AS total_revenue, -- Total sales value (paid + balance)
                    COUNT(DISTINCT t.property_id) AS total_properties_sold
                FROM
                    transactions t
                WHERE
                    t.transaction_date BETWEEN %s AND CONCAT(%s, ' 23:59:59')
            """
            result_row = self._execute_query(query, (start_date, end_date), fetch_one=True)

            return {
                'total_revenue': result_row['total_revenue'] if result_row and result_row['total_revenue'] is not None else 0.0,
                'total_properties_sold': result_row['total_properties_sold'] if result_row and result_row['total_properties_sold'] is not None else 0
            }
        except Exception as e:
            print(f"Error in get_total_sales_for_date_range: {e}")
            return {'total_revenue': 0.0, 'total_properties_sold': 0}

    def get_detailed_sales_transactions_for_date_range(self, start_date, end_date):
        """
        Retrieves detailed sales transactions for the accounting-style report.
        Includes property type (hardcoded to 'Land' for now), title deed, original price,
        amount paid, and balance.
        """
        try:
            query = """
                SELECT
                    p.title_deed_number AS title_deed,
                    p.price AS actual_price,
                    t.total_amount_paid AS amount_paid,
                    t.balance AS balance
                FROM
                    transactions t
                JOIN
                    properties p ON t.property_id = p.property_id
                WHERE
                    t.transaction_date BETWEEN %s AND CONCAT(%s, ' 23:59:59')
                ORDER BY t.transaction_date ASC
            """
            results_rows = self._execute_query(query, (start_date, end_date), fetch_all=True)
            return [dict(row) | {'property_type': 'Land'} for row in results_rows] if results_rows else []
        except Exception as e:
            print(f"Error in get_detailed_sales_transactions_for_date_range: {e}")
            return []

    def get_sold_properties_for_date_range_detailed(self, start_date, end_date):
        """
        Retrieves detailed information about properties sold within a specified date range.
        """
        try:
            query = """
                SELECT
                    p.title_deed_number,
                    p.location,
                    p.size,
                    t.transaction_date AS date_sold,
                    t.total_amount_paid,
                    t.balance,
                    c.name AS client_name
                FROM
                    transactions t
                JOIN
                    properties p ON t.property_id = p.property_id
                JOIN
                    clients c ON t.client_id = c.client_id
                WHERE
                    p.status = 'Sold' AND t.transaction_date BETWEEN %s AND CONCAT(%s, ' 23:59:59')
                ORDER BY t.transaction_date ASC
            """
            results_rows = self._execute_query(query, (start_date, end_date), fetch_all=True)
            return results_rows if results_rows else []
        except Exception as e:
            print(f"Error in get_sold_properties_for_date_range_detailed: {e}")
            return []

    def get_pending_instalments_for_date_range(self, start_date, end_date):
        """
        Retrieves information about transactions with a balance due within a specified date range.
        The date range applies to the transaction_date.
        """
        try:
            query = """
                SELECT
                    t.transaction_id,
                    t.transaction_date,
                    t.total_amount_paid,
                    t.discount,
                    t.balance,
                    p.title_deed_number,
                    p.price AS original_price,
                    c.name AS client_name,
                    c.contact_info AS client_contact_info
                FROM
                    transactions t
                JOIN
                    properties p ON t.property_id = p.property_id
                JOIN
                    clients c ON t.client_id = c.client_id
                WHERE
                    t.balance > 0 AND t.transaction_date BETWEEN %s AND CONCAT(%s, ' 23:59:59')
                ORDER BY t.transaction_date ASC
            """
            results_rows = self._execute_query(query, (start_date, end_date), fetch_all=True)
            return results_rows if results_rows else []
        except Exception as e:
            print(f"Error in get_pending_instalments_for_date_range: {e}")
            return []

    def get_all_agents(self):
        """Fetches all agent records from the 'agents' table as a list of dictionaries."""
        try:
            rows = self._execute_query(
                "SELECT agent_id, name, status, added_by, timestamp FROM agents",
                fetch_all=True
            )
            return rows if rows else []
        except Exception as e:
            print(f"Error fetching all agents: {e}")
            return []

    def add_agent(self, name, added_by):
        """
        Adds a new agent to the database.
        Returns: True if the agent was added successfully, False otherwise.
        """
        try:
            existing_agent = self._execute_query(
                "SELECT agent_id FROM agents WHERE name = %s",
                (name,), fetch_one=True
            )
            if existing_agent:
                print("Agent with this name already exists.")
                return False

            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            return self._execute_query(
                "INSERT INTO agents (name, status, added_by, timestamp) VALUES (%s, %s, %s, %s)",
                (name, 'active', added_by, timestamp)
            )
        except Exception as e:
            print(f"Error adding new agent: {e}")
            return False

    def get_agent_by_name(self, agent_name):
        """
        Fetches a single agent record from the 'agents' table by name.
        Returns: A dictionary containing the agent's data if found, otherwise None.
        """
        try:
            row = self._execute_query(
                "SELECT agent_id, name, status, added_by, timestamp FROM agents WHERE name = %s",
                (agent_name,),
                fetch_one=True
            )
            return row
        except Exception as e:
            print(f"Error fetching agent by name '{agent_name}': {e}")
            return None

    def update_agent(self, agent_id, new_name=None, new_status=None):
        """
        Updates the name or status of an existing agent.
        Returns: True if the update was successful, False otherwise.
        """
        updates = []
        params = []

        if new_name:
            updates.append("name = %s")
            params.append(new_name)
        if new_status:
            updates.append("status = %s")
            params.append(new_status)

        if not updates:
            print("No updates provided.")
            return False

        query = f"UPDATE agents SET {', '.join(updates)} WHERE agent_id = %s"
        params.append(agent_id)

        try:
            return self._execute_query(query, tuple(params))
        except Exception as e:
            print(f"Error updating agent: {e}")
            return False

    def delete_agent(self, agent_id):
        """
        Deletes an agent from the database.
        Returns: True if the agent was deleted, False otherwise.
        """
        try:
            return self._execute_query(
                "DELETE FROM agents WHERE agent_id = %s",
                (agent_id,)
            )
        except Exception as e:
            print(f"Error deleting agent: {e}")
            return False

    def check_if_user_is_agent(self, user_id):
        """
        Checks if a user is an agent by looking up their ID in the users table.

        Args:
            user_id (int): The ID of the user to check.

        Returns:
            bool: True if the user is an agent (is_agent = 'yes'), False otherwise.
        """
        try:
            conn = self._get_connection()
            if not conn: return False
            cursor = conn.cursor()

            cursor.execute("SELECT is_agent FROM users WHERE user_id = %s", (user_id,))
            result = cursor.fetchone()

            if result and result[0] == 'yes':
                return True
            return False

        except mysql.connector.Error as e:
            print(f"Database error checking if user is an agent: {e}")
            return False
        finally:
            if conn: conn.close()

    def get_agent_by_user_id(self, user_id):
        """
        Retrieves an agent's data from the users table by their user ID.

        Args:
            user_id (int): The ID of the user to retrieve.

        Returns:
            dict or None: A dictionary containing the user's data if they are an agent,
                           otherwise None.
        """
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor(dictionary=True)

            cursor.execute("SELECT * FROM users WHERE user_id = %s AND is_agent = 'yes'", (user_id,))
            return cursor.fetchone()

        except mysql.connector.Error as e:
            print(f"Database error fetching agent data: {e}")
            return None
        finally:
            if conn: conn.close()

    ############# NEW METHODS FOR PROPOSED LOTS UI ################
    def propose_new_lot(self, proposed_lot_data):
        """
        Inserts a new proposed lot record into the proposed_lots table.

        Args:
            proposed_lot_data (dict): A dictionary containing the details of the new lot.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return
            cursor = conn.cursor()
            cursor.execute('''
                INSERT INTO proposed_lots (parent_block_id, size, location, surveyor_name, created_by, title_deed_number, price, status)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            ''', (
                proposed_lot_data['parent_block_id'],
                proposed_lot_data['size'],
                proposed_lot_data['location'],
                proposed_lot_data['surveyor_name'],
                proposed_lot_data['created_by'],
                proposed_lot_data.get('title_deed_number', 'N/A'),
                str(proposed_lot_data.get('price', 0)),
                proposed_lot_data.get('status', 'Proposed')
            ))
            conn.commit()
        except mysql.connector.Error as e:
            print(f"MySQL error proposing new lot: {e}")
            if conn: conn.rollback()
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def create_payment_plan(self, plan_data):
        """
        Inserts a new payment plan record into the payment_plans table.

        Args:
            plan_data (dict): A dictionary containing the details of the new plan,
                              including 'name', 'duration_months', 'interest_rate',
                              and 'created_by'.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor()
            sql = """
            INSERT INTO payment_plans (name, deposit_percentage, duration_months, interest_rate, created_by)
            VALUES (%s, %s, %s, %s, %s);
            """
            cursor.execute(sql, (
                plan_data['name'],
                plan_data['deposit_percentage'],
                plan_data['duration_months'],
                plan_data['interest_rate'],
                plan_data['created_by']
            ))
            conn.commit()
            return cursor.lastrowid
        except mysql.connector.Error as e:
            print(f"MySQL error creating payment plan: {e}")
            if conn: conn.rollback()
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_payment_plans(self):
        """
        Retrieves all payment plans from the database.

        Returns:
            list: A list of dictionaries, where each dictionary represents a plan.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            sql = "SELECT plan_id, name, deposit_percentage, duration_months, interest_rate, created_by FROM payment_plans;"
            cursor.execute(sql)
            plans = cursor.fetchall()
            return plans
        except mysql.connector.Error as e:
            print(f"MySQL error getting payment plans: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_plan_by_id(self, plan_id):
        """
        Fetches a single payment plan from the database using its plan_id.

        Returns:
            dict: A dictionary of the plan details, or None if not found.
        """
        conn = None
        cursor = None
        plan_data = None
        try:
            conn = self._get_connection()
            if not conn: return None
            cursor = conn.cursor(dictionary=True)
            sql = "SELECT plan_id, name, deposit_percentage, duration_months, interest_rate, created_by FROM payment_plans WHERE plan_id = %s;"
            cursor.execute(sql, (plan_id,))
            plan_data = cursor.fetchone()
        except mysql.connector.Error as e:
            print(f"Database error while fetching plan: {e}")
        finally:
            if cursor: cursor.close()
            if conn: conn.close()
        return plan_data

    def update_payment_plan(self, plan_id, plan_data):
        """
        Updates an existing payment plan using the provided format.

        Args:
            plan_id (int): The ID of the plan to update.
            plan_data (dict): A dictionary with the new plan details.
                              Can contain 'name', 'duration_months', or 'interest_rate'.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE payment_plans
                SET name = %s, deposit_percentage = %s, duration_months = %s, interest_rate = %s
                WHERE plan_id = %s
            ''', (
                plan_data.get('name'),
                plan_data.get('deposit_percentage'),
                plan_data.get('duration_months'),
                plan_data.get('interest_rate'),
                plan_id
            ))
            conn.commit()
        except mysql.connector.Error as e:
            print(f"MySQL error updating payment plan: {e}")
            if conn: conn.rollback()
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def delete_payment_plan(self, plan_id):
        """
        Deletes a payment plan based on its ID using the new, simple format.

        Args:
            plan_id (int): The ID of the plan to delete.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return
            cursor = conn.cursor()
            cursor.execute('''
                DELETE FROM payment_plans WHERE plan_id = %s
            ''', (plan_id,))
            conn.commit()
        except mysql.connector.Error as e:
            print(f"MySQL error deleting payment plan: {e}")
            if conn: conn.rollback()
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def update_block_size(self, block_id, new_size):
        """
        Updates the size of a parent block in the properties table.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE properties
                SET size = %s
                WHERE property_id = %s
            ''', (new_size, block_id))
            conn.commit()
        except mysql.connector.Error as e:
            print(f"MySQL error updating block size: {e}")
            if conn: conn.rollback()
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_proposed_lots_with_details(self):
        """
        Retrieves all proposed lots with details from both tables.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            cursor.execute('''
                SELECT
                    p.title_deed_number,
                    pl.lot_id,
                    pl.size,
                    pl.location,
                    pl.surveyor_name,
                    pl.created_by,
                    pl.status
                FROM proposed_lots pl
                INNER JOIN properties p ON pl.parent_block_id = p.property_id
            ''')
            rows = cursor.fetchall()
            return rows
        except mysql.connector.Error as e:
            print(f"MySQL error getting proposed lots with details: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_lots_for_update(self):
        """
        Retrieves proposed or confirmed lots for potential updates.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return []
            cursor = conn.cursor(dictionary=True)
            cursor.execute('''
                SELECT lot_id, title_deed_number, size, status, location
                FROM proposed_lots
                WHERE status IN ('Proposed')
            ''')
            rows = cursor.fetchall()
            return rows
        except mysql.connector.Error as e:
            print(f"MySQL error getting lots for update: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_lot_details_for_rejection(self, lot_id):
        query = """
        SELECT parent_block_id, size
        FROM proposed_lots
        WHERE lot_id = %s
        """
        row = self._execute_query(query, (lot_id,), fetch_one=True)
        return row if row else None

    def finalize_lot(self, lot_id):
        """
        Updates the status of a proposed lot to 'Confirmed'.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE proposed_lots
                SET status = 'Confirmed'
                WHERE lot_id = %s
            ''', (lot_id,))
            conn.commit()
        except mysql.connector.Error as e:
            print(f"MySQL error finalizing lot: {e}")
            if conn: conn.rollback()
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def reject_lot(self, lot_id):
        """
        Updates the status of a proposed lot to 'Rejected'.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return
            cursor = conn.cursor()
            cursor.execute('''
                UPDATE proposed_lots
                SET status = 'Rejected'
                WHERE lot_id = %s
            ''', (lot_id,))
            conn.commit()
        except mysql.connector.Error as e:
            print(f"MySQL error rejecting lot: {e}")
            if conn: conn.rollback()
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def return_size_to_block(self, block_id, size_to_add):
        """
        Adds a specified size back to a parent block and updates its status if needed.

        Args:
            block_id (int): The ID of the parent block to update.
            size_to_add (float): The size to be added back.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return
            cursor = conn.cursor()

            cursor.execute("SELECT size, status FROM properties WHERE property_id = %s", (block_id,))
            result = cursor.fetchone()

            if result:
                current_size, current_status = result[0], result[1] # Access by index for non-dictionary cursor
                new_size = current_size + size_to_add
                new_status = 'Available' if current_status == 'Unavailable' else current_status

                cursor.execute("UPDATE properties SET size = %s, status = %s WHERE property_id = %s", (new_size, new_status, block_id))
                conn.commit()
                print(f"Size {size_to_add} successfully returned to block {block_id}. New size: {new_size}. New status: {new_status}.")
            else:
                print(f"Block with ID {block_id} not found.")

        except mysql.connector.Error as e:
            print(f"Database error occurred: {e}")
            if conn:
                conn.rollback()
        finally:
            if cursor: cursor.close()
            if conn: cursor.close()

    def update_block_status(self, block_id, status):
        """
        Updates the status of a block in the properties table.

        Args:
            block_id (int): The unique ID of the block to update.
            status (str): The new status to be set (e.g., 'Unavailable').
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return
            cursor = conn.cursor()
            sql = "UPDATE properties SET status = %s WHERE property_id = %s"
            cursor.execute(sql, (status, block_id))
            conn.commit()
            print(f"Status for block {block_id} successfully updated to '{status}'.")
        except mysql.connector.Error as e:
            print(f"Database error occurred: {e}")
            if conn:
                conn.rollback()
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    #NEW
    def get_client_properties(self, client_id):
        """
        Retrieves properties associated with a specific client.
        This assumes properties are linked to clients via transactions.
        """
        query = """
            SELECT p.property_id, p.title_deed_number, p.location, p.size, p.price, p.status,
                   t.transaction_date, t.total_amount_paid
            FROM properties p
            JOIN transactions t ON p.property_id = t.property_id
            WHERE t.client_id = %s
            ORDER BY t.transaction_date DESC
        """
        rows = self._execute_query(query, (client_id,), fetch_all=True)
        return rows if rows else []

    def get_client_survey_jobs(self, client_id):
        """
        Retrieves all survey jobs for a specific client.
        """
        query = """
            SELECT job_id, property_location, job_description, fee, amount_paid, balance,
                   deadline, status, created_at
            FROM survey_jobs
            WHERE client_id = %s
            ORDER BY created_at DESC
        """
        rows = self._execute_query(query, (client_id,), fetch_all=True)
        return rows if rows else []

    def get_all_propertiesForTransfer_paginated(self, limit=None, offset=None, search_query=None, min_size=None, max_size=None, status=None):
        """
        Fetches properties from 'properties' and 'propertiesForTransfer' with optional search,
        size filters, status, and pagination, including the username of the user who added them.
        Returns properties ordered by property_id DESC (newest first).
        Returns: A list of dictionaries, each representing a property.
        """
        query_parts = []
        params = []

        # Query for properties from the 'properties' table
        main_props_query = """
        SELECT
            p.property_id,
            p.title_deed_number,
            p.location,
            p.size,
            p.description,
            p.price,
            p.contact,
            p.image_paths,
            p.title_image_paths,
            p.status,
            p.added_by_user_id,
            p.owner,
            u.username AS added_by_username,
            'Main' AS source_table
        FROM properties p
        LEFT JOIN users u ON p.added_by_user_id = u.user_id
        """
        query_parts.append(main_props_query)
        # Query for properties from the 'propertiesForTransfer' table
        transfer_props_query = """
        SELECT
            pt.property_id,
            pt.title_deed_number,
            pt.location,
            pt.size,
            pt.description,
            NULL AS price,
            pt.contact,
            pt.image_paths,
            pt.title_image_paths,
            NULL AS status,
            pt.added_by_user_id,
            pt.owner,
            u.username AS added_by_username,
            'Transfer' AS source_table
        FROM propertiesForTransfer pt
        LEFT JOIN users u ON pt.added_by_user_id = u.user_id
        """
        query_parts.append(transfer_props_query)
        # Combine queries with UNION ALL
        combined_query = " UNION ALL ".join(query_parts)
        # Add WHERE clause and filters
        full_query = f"SELECT * FROM ({combined_query}) AS combined_results WHERE 1=1"
        if search_query:
            full_query += " AND (title_deed_number LIKE %s OR location LIKE %s OR description LIKE %s)"
            params.extend([f"%{search_query}%", f"%{search_query}%", f"%{search_query}%"])

        if min_size is not None:
            full_query += " AND size >= %s"
            params.append(min_size)

        if max_size is not None:
            full_query += " AND size <= %s"
            params.append(max_size)

        if status:
            full_query += " AND status = %s"
            params.append(status)

        full_query += " ORDER BY property_id DESC"
        if limit is not None:
            full_query += " LIMIT %s"
            params.append(limit)
        if offset is not None:
            full_query += " OFFSET %s"
            params.append(offset)
        results_rows = self._execute_query(full_query, tuple(params), fetch_all=True)
        return results_rows if results_rows else []

    def get_property_by_source(self, property_id, source_table):
        """
        Fetches a single property from either the 'properties' or 'propertiesForTransfer' table
        based on its property ID and source table.
        """
        results_row = None
        if source_table == 'Main':
           query = """
           SELECT
               p.property_id, p.title_deed_number, p.location, p.size, p.description,
               p.price, p.contact, p.image_paths, p.title_image_paths, p.status,
               p.added_by_user_id, p.owner, u.username AS added_by_username
           FROM properties p
           LEFT JOIN users u ON p.added_by_user_id = u.user_id
           WHERE p.property_id = %s
           """
           results_row = self._execute_query(query, (property_id,), fetch_one=True)
        elif source_table == 'Transfer':
           query = """
           SELECT
               pt.property_id, pt.title_deed_number, pt.location, pt.size, pt.description,
               NULL AS price, pt.contact, pt.image_paths, pt.title_image_paths, NULL AS status,
               pt.added_by_user_id, pt.owner, u.username AS added_by_username
           FROM propertiesForTransfer pt
           LEFT JOIN users u ON pt.added_by_user_id = u.user_id
           WHERE pt.property_id = %s
           """
           results_row = self._execute_query(query, (property_id,), fetch_one=True)

        return results_row if results_row else None

    def execute_property_transfer(self, property_id, from_client_id, to_client_id, transfer_price, transfer_date, executed_by_user_id, supervising_agent_id, document_path, source_table):
        """
        Executes a property transfer transaction:
        1. Updates the owner in the correct table (properties or propertiesForTransfer).
        2. Records the transfer details in the property_transfers table.

        Returns: True on success, False on failure.
        """
        conn = None
        cursor = None
        try:
            conn = self._get_connection()
            if not conn: return False
            cursor = conn.cursor()

            cursor.execute("START TRANSACTION")

            cursor.execute("SELECT name FROM clients WHERE client_id = %s", (to_client_id,))
            new_owner_name = cursor.fetchone()

            if new_owner_name:
                new_owner_name = new_owner_name[0]
            else:
                raise ValueError(f"Client with ID {to_client_id} not found.")

            if source_table == 'Main':
                cursor.execute("UPDATE properties SET owner = %s WHERE property_id = %s", (new_owner_name, property_id))
            elif source_table == 'Transfer':
                cursor.execute("UPDATE propertiesForTransfer SET owner = %s WHERE property_id = %s", (new_owner_name, property_id))
            else:
                raise ValueError(f"Invalid source table: {source_table}")

            transfer_record_query = """
            INSERT INTO property_transfers (
                property_id, from_client_id, to_client_id, transfer_price,
                transfer_date, executed_by_user_id, supervising_agent_id,
                transfer_document_path
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """
            cursor.execute(transfer_record_query, (
                property_id, from_client_id, to_client_id, transfer_price,
                transfer_date, executed_by_user_id, supervising_agent_id,
                document_path
            ))

            conn.commit()
            return True

        except Exception as e:
            if conn:
                conn.rollback()
            print(f"Database error during property transfer: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()
